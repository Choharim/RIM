---

title:  실행 컨텍스트
description:  자바스크립트 코드를 실행하기 위해 필요한 환경 정보를 담고있는 실행 컨텍스트의 구조와 작동 방식을 살펴보자. 이를 통해 코드가 어떻게 평가되고 실행 되는지 알아보자.
createDate: 2023.1.9
category: javascript

---
## 스코프

 식별자(변수 이름, 함수 이름, 클래스 이름 등)의 선언된 위치에 따라 다른 코드가 해당 식별자를 참조할 수 있는 유효 범위가 결정된다. 스코프는 식별자가 유효한 범위를 말한다.

스코프 내에서 식별자는 유일해야 하지만 다른 스코프에서는 같은 이름의 식별자를 사용할 수 있다. (var로 선언된 변수는 같은 스코프 내 중복 선언이 가능하다.)

### 스코프 체인

현재 실행 중인 실행 컨텍스트의 렉시컬 환경에서 시작하여 외부 렉시컬 환경에 대한 참조로 이어지는 `렉시컬 환경의 연속`이다. 체인처럼 스코프가 계층적으로 연결된 것이다. 단일 연결 리스트 자료구조로 스코프 체인을 구현한다.

자바스크립트 엔진이 식별자를 만나면 스코프 체인을 통해 현재 스코프에서 상위 스코프 방향으로 이동하며 해당 식별자를 검색한다. 상위 스코프에서 선언한 식별자를 하위 스코프에서 참조할 수 있지만, 하위 스코프에서 선언한 식별자를 상위 스코프에서 참조할 수 없는 이유이다.

### 함수 레벨 스코프

함수 코드 블록만 지역 스코프로 보는 특성이다. var로 선언된 변수는 함수 레벨 스코프를 따른다.

### 블록 레벨 스코프

모든 코드 블록(함수, if, for, while, switch 등)을 지역 스코프로 보는 특성이다. let, const로 선언된 변수는 블록 레벨 스코프를 따른다.

## 실행 컨텍스트

실행 컨텍스트는 식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 `내부 매커니즘`이다.
`식별자와 스코프는 렉시컬 환경으로 관리`하고, `코드 실행 순서는 실행 컨텍스트 스택으로 관리`한다.

### 렉시컬 환경

스코프를 구분하여 식별자와 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 등록하고 관리하는 자료구조이다.

> 환경 레코드
> 

스코프에 포함된 식별자를 key로 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소이다.

> 외부 렉시컬 환경에 대한 참조
> 

해당 실행 컨텍스트를 생성한 소스 코드를 포함하는 상위 코드의 렉시컬 환경 즉, 상위 스코프를 말한다.

### 실행 컨텍스트 스택

Stack으로 실행 컨텍스트를 관리하여 코드의 실행순서를 기억한다. 

## 소스코드의 평가와 실행

자바스크립트 엔진은 모든 소스 코드를 평가한 후 실행한다.

### 평가 과정

소스 코드가 평가되면 실행 컨텍스트가 생성되고 실행 컨텍스트 스택의 최상위에 쌓인다.

### 실행 과정

1. 선언문을 제외한 소스코드가 순차적으로 실행된다. 
2. 소스코드 실행에 필요한 정보(변수나 함수의 참조)는 스코프에서 검색해 취득한다.
3. 소스 코드의 실행 중 변경된 변수 값이나 실행 결과를 스코프에 등록한다.

> 소스 코드는 크게 전역 코드, 함수 코드, eval 코드, 모듈 코드로 구분되며 이에 따라 실행 컨텍스트를 생성한다.
> 

## 전역 코드

전역에 존재하는 소스코드이다. (전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않는다.)

<aside>
❓ 전역 객체   
전역 객체는 전역 코드가 평가되기 전에 생성된다. 전역 객체에는 빌트인 전역 프로퍼티, 빌트인 전역 함수, 표준 빌트인 객체가 추가되며 동작 환경에 따라 Web API 또는 특정 환경을 위한 호스트 객체를 포함한다. 전역 객체도 Object.prototype을 상속받는 프로토타입 체인의 일원이다.

</aside>

### 평가

1. `전역 실행 컨텍스트`가 생성된다.
2. `전역 렉시컬 환경`이 생성되고 전역 실행 컨텍스트에 바인딩한다.
    - `전역 환경 레코드` 생성  
    전역 코드 평가 과정에서 전역 변수의 변수 선언문과 함수 선언문이 먼저 실행되고 그 결과 생성된 전역 변수와 전역 함수가 환경 레코드에 등록된다.
        - `객체 환경 레코드` 생성  
        var 전역 변수, 함수 선언문으로 정의된 전역 함수, 빌트인 전역 프로퍼티, 빌트인 전역 함수, 표준 빌트인 객체를 관리한다. var로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티와 메서드가 된다.        
        - `선언적 환경 레코드` 생성  
        let, const 전역 변수가 등록되고 관리된다. 전역 객체의 프로퍼티가 되지 않는다.
        - this 바인딩  
        전역 환경 레코드의 내부 슬롯에 this가 바인딩된다. 일반적으로 전역 코드에서 this는 전역 객체를 가리킨다.
<aside>
💡 var 전역 변수  
전역 코드 평가 과정에서 전역 객체에 변수 식별자가 key로 등록되고 암묵적으로 undefined가 바인딩된다. 선언과 초기화가 동시에 진행되는 것이다. 이것이 var 변수가 호이스팅 되는 원리이다.

</aside>

<aside>
💡 함수 선언문  
전역 코드 평가 과정에서 전역 객체에 함수 이름의 식별자가 key로 등록되고, 생성된 함수 객체가 즉시 할당된다. 이것이 함수가 호이스팅되는 원리이다.

</aside>
               
<aside>
💡 let, const 전역 변수  
전역 코드 평가 과정에서 전역 객체에 변수 식별자가 key로 등록되고 값은 바인딩되지 않는다. 선언 되었을 때 초기화가 되지 않는 것이다. 
실행 과정에서 실행 흐름이 변수 선언문에 도달하면 초기화/할당된다. 때문에 변수 호이스팅이 되지만 `변수 선언문에 도달하기 전, 일시적 사각지대`(Temporal Dead Zone)에서는 참조할 수 없다. TDZ에서 접근하면 ReferenceError가 발생한다.

</aside>
        
    - `외부 렉시컬 환경에 대한 참조` 저장   
    전역 코드의 상위 스코프는 없으므로 null이다.
3. 생성된 실행 컨텍스트는 실행 컨텍스트 스택에 push된다.

### 실행

1. 런타임이 시작되어 전역 코드가 순차적으로 실행되기 시작한다.
2. 소스 코드 평가 과정에서 실행된 변수 선언문이나 함수 선언문은 실행되지 않는다.
3. 변수 할당문 또는 함수 호출문을 만나면 필요한 식별자를 스코프 체인을 통해 검색한다. 검색된다면 변수에 할당된 값은 환경 레코드의 해당 식별자에 바인딩되고, 함수의 경우 호출된다. (검색이 안되면 ReferenceError에러가 발생한다.)
4. 함수가 호출되면 순차적으로 실행되던 전역 코드의 실행을 일시 중단하고 코드 실행 순서를 변경하여 함수 내부로 진입한다.
5. 더 이상 실행할 전역 코드가 남아있지 않으면 전역 컨텍스트가 실행 컨텍스트 스택에서 pop된다.

## 함수 코드

함수 내부에 존재하는 소스코드이다. (함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다.)

### 평가

함수가 호출되면 함수 내부로 진입하여 함수 코드가 평가된다.

1. `함수 실행 컨텍스트`가 생성된다.
2. `함수 렉시컬 환경` 이 생성되고 함수 실행 컨텍스트에 바인딩한다.
    - `함수 환경 레코드` 생성
        - 매개변수, 지역 변수, arguments 객체, 중첩 함수를 등록하고 관리한다.
        - this 바인딩
        함수 환경 레코드의 내부 슬롯에 this가 바인딩된다.
    - `외부 렉시컬 환경에 대한 참조` 결정   
<aside>
❓ 렉시컬 스코프 (= 정적 스코프)  
자바스크립트는 렉시컬 스코프를 따른다.
상위 스코프가 동적으로 변하지 않고 `함수 정의가 평가된 시점에 상위 스코프가 결정`되는 것이다. 즉, 함수를 어디서 호출했는지가 아닌, 어디에 정의했는지에 따라 상위 스코프를 결정한다. 그래서 항상 `함수의 상위 스코프는 자신이 정의된 스코프`이다.

</aside>
        
3. 함수 렉시컬 환경이 완성된 후 실행 컨텍스트가 실행 컨텍스트 스택에 push된다.

### 실행

1. 런타임이 시작되어 함수 코드가 순차적으로 실행되기 시작한다.
2. 매개변수에 인수가 할당되고, 지역 변수 힐당문을 만나면 스코프 체인을 통해 식별자를 검색한다. 식별자를 찾으면 할당된 값을 바인딩한다. (식별자를 찾을 수 없다면 ReferenceError가 발생한다.)
3. 메서드를 만나면 스코프 체인을 통해 검색한다. 
    1. console.log(a + x + y)가 호출된다.
    2. 식별자인 console을 스코프 체인을 통해 검색한다. 
    console같은 경우, 전역 레시컬 환경에서의 전역 객체에서 찾는다.
    3. log 프로퍼티를 console 객체의 프로토타입 체인을 통해 검색한다.
    4. 인수로 전달된 표현식 a + x + y를 평가한다.
        1. 변수 a,x,y는 스코프 체인을 통해 검색한다.
4. 함수가 종료되면 자바스트립트 엔진이 해당 함수 실행 컨텍스트를 실행 컨텍스트 스택에서 pop하여 제거한다.

## 코드의 평가와 실행 순서

```jsx
const x = 1;

function foo(){
 const y = 2;
 
 function bar(){
   const z = 3;
   console.log(x + y + z);
 }
 bar();
}

foo();
```

1. 전역 코드를 평가한다.
    1-1. 전역 실행 컨텍스트가 생성된다.
    1-2. 변수 선언문과 함수 선언문이 전역 실행 컨텍스트에 등록된다.
        1. x 변수가 등록되고 초기화는 되지 않는다.
        2. foo 함수가 등록되고 함수 객체가 할당된다.
    3. 생성된 전역 실행 컨텍스트가 실행 컨텍스트 스택에 push된다.
2. 전역 코드가 실행된다.
    1. 변수 할당문을 만나 식별자를 검색하고 해당 식별자에 할당된 값을 바인딩한다.
        1. x 변수에 값 1이 할당된다.
    2. foo 함수가 호출된다.
3. 전역 코드의 실행이 일시 중단되고 foo함수가 평가된다.
    1. foo함수 실행 컨텍스트가 생성된다.
    2. 변수 선언문과 함수 선언문이 foo함수 실행 컨텍스트에 등록된다.
        1. y변수가 등록되고 초기화는 되지 않는다.
        2. bar함수가 등록되고 함수 객체가 할당된다.
    3. 생성된 foo함수 실행 컨텍스트가 실행 컨텍스트 스택에 push된다.
4. foo함수가 실행된다.
    1. 변수 할당문을 만나 식별자를 검색하고 해당 식별자에 할당된 값을 바인딩한다.
        1. y 변수에 값 2가 할당된다.
        2. bar함수가 호출된다.
5. foo함수의 실행이 일시 중단되고 bar함수가 평가된다.
1. bar함수의 실행 컨텍스트가 생성된다.
2. 변수 선언문이 bar함수 실행 컨텍스트에 등록된다.
    1. z변수가 등록되고 초기화는 되지 않는다.
3. 생성된 bar함수 실행 컨텍스트가 실행 컨텍스트 스택에 push된다.
1. bar함수가 실행된다.
    1. 변수 할당문을 만나 식별자를 검색하고 해당 식별자에 할당된 값을 바인딩한다.
        1. z 변수에 값 3이 할당된다.
        2. console.log(x + y + z)가 호출된다.
        ⇒ 평가 과정을 거친 후 실행된다.
2. bar함수가 종료된다.
3. bar함수 실행 컨텍스트가 실행 컨텍스트 스택에서 pop된다.
4. foo함수가 종료된다.
5. foo함수 실행 컨텍스트가 실행 컨텍스트 스택에서 pop된다.
6. 전역 실행 컨텍스트가 실행 컨텍스트 스택에서 pop된다.
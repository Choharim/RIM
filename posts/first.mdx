---
title: Big O
description: 시간 복잡도와 공간 복잡도를 파악하자
createAt: '2022-10-03'
tags: [알고리즘]
---

# 시간 복잡도(Time Complexity)

## O(1)

- 산수
- 변수 배정
- 인덱스로 배열의 요소에 접근하는 것
- 오브젝트의 키로 값에 접근하는 것

## O(n), O(n^2)…

- 루프가 존재하면, 루프의 길이 곱하기 루프 안 연산들

## Example

```jsx
/* O(n)
 * n > 5, n이 커질수록 time complexity가 1:1로 비례하므로 O(n)이 된다.
 */
function logAtLeast5(n) {
  for (let i = 1; i <= Math.max(5, n); i++) {
    console.log(i)
  }
}
```

```jsx
/* O(1)
 * n >=5, time complexity 5이므로 O(1)이 된다.
 */
function logAtMost5(n) {
  for (let i = 1; i <= Math.min(5, n); i++) {
    console.log(i)
  }
}
```

# 공간 복잡도 (Space Complexity)

\*input의 메모리가 아닌 ‘알고리즘이 차지하는 보조 공간 복잡도’를 이야기 하는 것.

- number, boolean, null, undefined는 상수 공간 O(1)
  (숫자가 1이든 10000이든 같은 공간을 차지함)
- string는 길이 만큼의 공간이 필요 O(n)
- reference type O(n)
  array는 길이만큼의 공간이 필요
  object는 key의 갯수만큼 공간이 필요

## Example

```jsx
// O(1)
function sum(array) {
  let total = 0
  for (let i = 0; i < array.length; i++) {
    total += array[i]
  }
  return total
}
```

```jsx
// O(n)
// newArray의 space complexity는 array의 길이와 동일 n + i는 1 => O(n)
function double(array) {
  let newArray = []
  for (let i = 0; i < array.length; i++) {
    newArray.push(2 * array[i])
  }
  return newArray
}
```

# JS Big O

### Object

- access O(1)
- insertion O(1)
- removal O(1)
- searching O(n)

### Object Methods

- Object.keys O(n)
- Object.values O(n)
- Object.entries O(n)
- hasOwnProperty O(1)

### Array

- access O(1)
- insertion 정렬되어 있는 위치에 따라 다름
  마지막에 추가하면 O(1)이지만,
  맨 앞에 추가하면 모든 요소의 인덱스가 1씩 밀려나기 때문에 O(n)이 된다.
- removal 정렬되어 있는 위치에 따라 다름
  마지막 요소를 제거하면 O(1)이지만,
  맨 앞 요소를 제거하면 모든 요소의 인덱스가 1씩 당겨지기 때문에 O(n)이 된다.
- searching O(n)

### Array Methods

- push O(1)
- pop O(1)
- shift O(n)
- unshift O(n)
- concat O(n)
  이어붙일 array의 길이만큼 time complexity는 커질 것
- slice O(n)
- splice O(n)
- sort O(n \* logN)
- forEach O(n)
- map O(n)
- filter O(n)
- reduce O(n)
- …etc O(n)

---
title: 프로세스
description: CPU는 한 번에 하나의 프로세스만 실행할 수 있기 때문에 여러 응용 프로그램이 실행되려면 운영체제가 적절히 CPU을 배분해주어야 한다. 시분할 시스템에서 운영체제가 프로그램을 관리 및 실행하는 과정을 살펴보자.
createDate: 2022.12.18
category: operating-system
---

## 프로세스 vs 프로그램

`프로그램은 어떤 작업을 할 건지 절차`가 저장장치에 `저장되어 있는 정적 상태`이다.

`프로세스는 프로그램이 메모리에 올라와 실행된 동적 상태`이다. 시스템의 작업 단위이고 테스크라도 한다.

<Picture src="process1.png" height={400} />

## 프로세스의 구조

> 코드 영역(텍스트 영역)

프로그램의 본문이 기술 된 곳이다. 프로세스가 실행되는 동안 변하지 않는 읽기 전용으로, 정적 할당 영역이다.

> 데이터 영역

본문에 사용되는 데이터가 저장되어 있다. 선언할 때 크기가 결정되므로 프로세스가 실행되는 동안 변하지 않는 읽기 전용, 정적 할당 영역이다.

> 힙 영역

동적으로 할당되는 변수 영역이다. `프로세스가 실행되는 동안 만들어지는` 영역으로, `크기가 변경될 수 있는 동적 할당 영역`이다. 읽기 쓰기가 가능하다.

> 스택 영역

프로세스를 작동하기 위해 커널이 유지하는 자료구조이다. 함수 호출 후 복귀시 돌아오는 메모리 주소와 지역 변수 등이 저장된다.

`하나의 스레드(CPU 작업 단위)가 작업하기 위해 하나의 스택이 할당`되고, 스레드가 작동하는 동안 추가되거나 삭제되는 동적 할당 영역이다.

## 프로세스 제어 블록 (PCB- process control block)

운영체제가 해당 `프로세스를 실행하기 위해 필요한 데이터를 보관`하는 자료 구조로, `모든 프로세스는 고유의 PCB를 갖는다.`

### 구성

> 프로세스 구분자 (PID)

프로세스 별로 구분하기 위한 고유 식별자이다.

> 부모 / 자식 프로세스 구분자 (PPID, CPID)

해당 프로세스가 파생된 부모 식별자와 해당 프로세스가 만든 자식 식별자이다.

> 프로세스 상태

프로세스가 현재 어떤 상태를 갖는지 나타낸다. Context를 이어가기 위함이다.

> 포인터

준비 상태와 대기 상태에서 사용되는 Queue의 포인터이다.

> 프로세스 우선순위

높은 우선순위를 갖는 프로세스가 먼저 실행되고 더 자주 실행된다. 커널 프로세스가 사용자 프로세스 보다 우선순위가 높고, 커널과 사용자 프로세스끼리도 우선순위가 다르다.

> 프로그램 카운터

다음 실행될 명령어의 위치를 가리키는 카운터의 값을 저장한다.

> 각종 레지스터 정보

사용하던 레지스터의 중간값을 보관하여 다음 실행에 사용한다.

> 메모리 관리 정보

프로세스의 메모리 위치 정보와 메모리 보호를 위한 경계/한계 레지스터 값이 저장된다.

> 할당된 자원 정보

프로세스를 실행하기 위해 할당된 자원 정보(입출력 자원, 오픈 파일 등)가 저장된다.

> 계정 정보

CPU 할당 시간과 사용 시간, 계정 번호 등이 저장된다.

## 프로세스 시스템

### 일괄 작업 시스템

프로세스가 생성되면 실행되고 완료된다. 하나의 프로세스가 완료된 후 새로운 프로세스가 실행될 수 있다.

### 시분할 시스템

`시간을 잘게 쪼개어 여러 프로세스에게 배분` 해줌으로써 여러 프로세스가 동시에 실행되는 것처럼 작동한다.

## 프로세스의 상태

시분할 시스템에서 운영체제가 어떻게 시간을 쪼개어 여러 프로세스에 CPU를 배분해주는지 살펴보자.

<Picture src="process2.png" height={650} />

### 생성 상태

프로세스가 생성되는 상태이다.

<aside>
💡 프로그램이 프로세스가 되려면 메모리에 올라오는 동시에 프로세스 제어 블록이 생성되어야 한다.

</aside>

1. 운영체제가 저장 장치에 있던 `프로그램을 메모리로 가져온다.` 자세히 말해, 가상 메모리를 할당해준다.
2. 해당 프로세스를 처리하는 작업 지시서인 `프로세스 제어 블록 (PCB)을 메모리의 운영체제 영역에 생성`한다.

### 준비 상태

생성된 프로세스가 `우선순위 별로 Queue (우선순위 다단계 큐)에서 CPU를 얻을 때까지 기다리는 상태`이다. CPU는 한 번에 하나의 프로세스만 실행할 수 있기 때문이다. (사실 CPU의 작업 단위는 스레드이기 때문에 프로세스가 아니라 스레드이다.)

### 실행 상태

`CPU 스케쥴러가 해당 프로세스 제어 블록을 CPU에 전달`하여 해당 프로세스가 실행되는 상태이다. `디스패치(Dispatch)`작업이라 한다.

`배당된 작업 시간(Time Slice, Time Quantum)동안만 CPU를 사용할 권리를 갖으며, 자신의 작업이 끝날 때까지 준비와 실행 상태를 왔다 갔다 한다.` 배당된 작업 시간이 지나면 작업이 완료되지 않았더라도 클록(Clock)의 인터럽트로 인해 준비 상태로 다시 이동한다. 작업을 끝내지 못하고 다시 준비 상태로 돌아가는 것을 `Time Out`이라 한다.

<aside>
❓ **문맥 교환 (Context Switching)**  
CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업이다. 두 프로세스의 제어 블록이 교환된다.

</aside>

### 완료 상태

프로세스의 작업이 완료된 상태로 `메모리에서 삭제되고 프로세스 제어 블록이 폐기`된다.

### 대기 상태

`프로세스가 입출력을 요구하면 입출력 관리자에 의해 입출력이 완료될 때까지 같은 입출력 장치별로 마련된 Queue(입출력 다단계 큐)에서 기다리는 상태`가 된다. 이때, `CPU 스케쥴러는 준비 상태에 있는 다른 프로세스 하나를 실행 상태로 만든다.`
입출력이 완료되면 `입출력 관리자로부터 인터럽트`를 받고, 인터럽트가 온 입출력 장치의 Queue에서 해당 프로세스 블럭을 찾아 준비 상태로 이동시킨다.

<aside>
➕ **하드웨어의 IRQ (Interupt ReQuest)**  
하드웨어의 고유 IRQ가 존재하는 것도 입출력 Queue와 관련이 있다. 하드웨어의 입출력 완료 인터럽트가 발생해 장치별로 구분된 Queue에서 해당 인터럽트의 PCB를 꺼낼 때, `IRQ를 사용하여 인터럽트와 관련된 장치를 식별함`으로써 인터럽트 핸들러는 `모든 Queue를 검색하지 않고도 효율적으로 라우팅할 수 있기 때문`이다. 그리고 `하드웨어 인터럽트의 우선순위에 따라 인터럽트를 처리`할 수 있게 한다.

</aside>

### 휴식 상태

프로세스가 작업의 휴식을 요청한 상태로 `사용하던 데이터가 메모리에 그대로 있고 프로세스 제어 블록도 유지된다.`

`프로세스가 실행 중에 중단되면 준비 상태로 이동되고 휴식 상태를 갖는다.` `PCB가 유지되기 때문에 재실행될 때 중단된 지점에서 작업을 이어갈 수 있다.`

보류 상태와는 다르게 `프로세스가 자발적으로 선택한 상태`이다. 프로세스는 ms 시간 단위로 Sleep을 요청하는데, 요청한 시간이 지난 후 프로세스가 실행 되는 것이 아니다. 휴식 상태로 들어가기 위해 준비 Queue에서 선택되고(dequeue), 요청한 휴식 시간이 지난 후 다시 준비 Queue에 재진입(enqueue)하고, 자신의 차례가 될 때까지 기다리는 시간까지 합쳐져 요청한 시간에 + a 시간이 소요된다.

### 보류 상태

`프로세스가 메모리 밖으로 잠시 쫒겨난 상태로 스왑 영역에 보관`된다. 컴퓨터의 성능을 떨어트리거나 실행을 미루어도 큰 지장이 없는 프로세스가 보류 상태로 이동한다. 프로세스가 운영체제에 의해 쫒겨났기 때문에 `자발적 상태 변환이 아니다.`

프로세스가 보류 상태로 이동하는 상황은 다음과 같다.

- 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫒아도 큰 문제가 없을 때
- 입출력이 계속 지연될 때
- 메모리가 꽉 찼을 때
- 프로그램에 오류가 있을 때
- 악의적 프로세스일 때

> 보류 대기 상태

`대기 상태에서 옮겨진 보류 상태`로, 재시작 하면 대기 상태로 이동한다. 입출력을 요청했던 프로세스가 보류 대기 상태에 있다가 입출력 완료 인터럽트를 받게되면 해당 프로세스 제어 블록은 보류 준비 상태로 이동한다.

> 보류 준비 상태

`준비 상태에서 옮겨진 보류 상태`로, 재시작하면 준비 상태로 이동한다.

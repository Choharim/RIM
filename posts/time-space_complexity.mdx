---
title: Big O
description: 빅오 표기법으로 알고리즘의 실행속도와 알고리즘이 실행되는 동안 차지하는 임시 메모리를 파악할 수 있다. 빅오는 정확도가 아니라 전체적인 추세에 초점을 맞춘다. 이를 통해 효과적인 알고리즘이 무엇인지 판단하고 비교할 수 있다.
createDate: '2022.10.3'
tag: 알고리즘
thumbnail: /thumbnail/time-space_complexity.png
---

# 시간 복잡도(Time Complexity)

> 알고리즘이 얼마나 빠르게 실행하는지 파악하는 척도이다.

## O(1)

`f(n) = 1`

n이 무한으로 커졌을 때의 전반적인 추이가 constant인 복잡도이다. 다시말해, one step으로 접근할 수 있는 상태이다.

### Example

- 산수  
  ⇒ 1 + 2
- 변수 배정  
  ⇒ let a
- 인덱스로 배열의 요소에 접근하는 것  
  ⇒ array[1]
- 오브젝트의 키로 값에 접근하는 것  
  ⇒ object.a

## O(n), O(n^2)…

`f(n) = n`

`f(n) = n^2`

- 루프가 존재하면, 루프의 길이 곱하기 루프 안 연산들이 존재하는 복잡도이다.

### Example

```jsx
/* O(n)
 * n <= 5, n이 커져도 5로 상수 복잡도 O(1)이 된다.
 * n > 5, n이 커질수록 복잡도와 1:1로 비례하므로 O(n)이 된다.
 * n > 5의 경우가 대부분이므로 전반적 추세로 보아 O(n)의 time complexity를 갖는다.
 */
function logAtLeast5(n) {
  for (let i = 1; i <= Math.max(5, n); i++) {
    console.log(i)
  }
}
```

```jsx
/* O(1)
 * n < 5, n이 커질 수록 복잡도도 n으로 비례하므로 O(n)이 된다.
 * n >= 5, n이 커져도 복잡도가 5로 일정하이므로 O(1)이 된다.
 * n >=5의 경우가 대부분이므로 전반적 추세로 보아 O(1)의 time complexity를 갖는다.
 */
function logAtMost5(n) {
  for (let i = 1; i <= Math.min(5, n); i++) {
    console.log(i)
  }
}
```

---

# 공간 복잡도 (Space Complexity)

> input의 메모리가 아닌 `알고리즘이 차지하는 보조 공간 복잡도`를 나타내는 것이다. 보조 공간이란 알고리즘이 실행되는 동안 사용하는 임시공간이다.

## O(1)

number, boolean, null, undefined는 불변 공간으로, input이 1이든 10000이든 같은 공간을 차지한다.

### Example

```jsx
// O(1)
function sum(array) {
  let total = 0
  for (let i = 0; i < array.length; i++) {
    total += array[i]
  }
  return total
}
```

## O(n)

- string는 문자 길이 만큼의 공간이 필요하다.
- reference type의 공간 복잡도로, Array는 길이만큼의 공간이 필요하고 Object는 key의 갯수만큼 공간이 필요하다.

### Example

```jsx
/* O(n)
 * newArray의 space complexity는 array의 길이와 동일하다.
 * n + i는 1 => O(n)
 */
function double(array) {
  let newArray = []
  for (let i = 0; i < array.length; i++) {
    newArray.push(2 * array[i])
  }
  return newArray
}
```

## O(log)

일반적으로 수학에서 밑이 10일 때 생략하지만 BigO에서는 밑이 2일 때 생략한다.
N: input
logN

input이 1보다 작아지기 전에 2로 나눠지는 횟수를 뜻한다.
예를 들어, log8은 8이 1보다 작아지기 전 2로 나눠지는 횟수가 3번이므로 3이 된다고 말할 수 있다.

---

# Object의 BigO

### Access O(1)

특정 key의 value에 접근할 때는 한번에 접근할 수 있으므로 time complexity가 O(1)이다.

### insertion O(1)

새로운 key를 one step으로 접근하여 삽입할 수 있으므로 time complexity가 O(1)이다.

### removal O(1)

특정 key를 제거할 때 해당 key에 바로 접근하여 제거할 수 있으므로 time complexity가 O(1)이다.

### searching O(n)

특정 value를 가진 key가 존재하는지 검색하기 위해서는 모든 최대로 모든 key에 접근하여 확인을 해야하므로 time complexity가 O(n)이다.

### Object Methods

- Object.keys O(n)
- Object.values O(n)
- Object.entries O(n)
- hasOwnProperty O(1)

# Array의 BigO

object와 큰 차이점은 순서가 존재한다는 것이다.

### Access O(1)

index로 바로 접근이 가능하기 때문에 time complexity가 O(1)이다.

### insertion O(n)

정렬되어 있는 위치에 따라 다르다.
마지막에 추가하면 O(1)이지만, 맨 앞에 추가하면 모든 요소의 인덱스가 1씩 밀려나기 때문에 O(n)이 된다.

### removal O(n)

정렬되어 있는 위치에 따라 다르다.
마지막 요소를 제거하면 O(1)이지만, 맨 앞 요소를 제거하면 모든 요소의 인덱스가 1씩 당겨지기 때문에 O(n)이 된다.

### searching O(n)

### Array Methods

- push O(1)
- pop O(1)
- shift O(n)
- unshift O(n)
- concat O(n)
  이어붙일 array의 길이만큼 걸리는 시간이 증가하기 때문이다.
- slice O(n)
  복사하는 element 갯수만큼 걸리는 시간이 증가하기 때문이다.
- splice O(n)
- sort O(n _ logN)
  정렬할 element의 갯수 _
  array를 돌면서 두개씩 비교하며 정렬하기 때문에
  array 길이 n \* 비교 횟수 logN이 된다.
- forEach O(n)
- map O(n)
- filter O(n)
- reduce O(n)
- …etc O(n)

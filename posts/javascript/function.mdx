---
title: 함수
description: 함수는 선언문과 표현식으로 정의하여 사용할 수 있다. 호이스팅에서 어떤 차이를 보이는 지 알아보자. 일반 함수와 화살표 함수도 비교해보자.
createDate: 2023.1.17
category: javascript
---

## 일급 객체

자바스크립트 함수는 일급 객체이다. 함수가 변수에 할당되거나 프로퍼티 값이 되거나 배열의 요소가 되는 등 `값 처럼 사용할 수 있다`는 의미이다.

## 함수 선언문

```jsx
function foo() {
  console.log('foo')
}

foo()
```

> foo라는 `함수 이름은 함수 몸체 내에서만 참조할 수 있기 때문에 함수 이름으로 함수를 호출할 수 없다.` 그럼 어떻게 foo로 함수를 호출할 수 있었을까?

```jsx
var foo = function foo() {
  console.log('foo')
}

foo()
```

JS 엔진이 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 함수 객체를 할당한다. 그래서 함수 이름이 아닌 foo라는 `식별자` 로 함수를 호출할 수 있는 것이다. 그렇기 때문에 함수 선언문은 함수 이름을 생략할 수 없다.

### 호이스팅

소스 코드 평가 과정에서 함수 선언문이 환경 레코드에 등록되기 때문에 실행 과정에서 함수 선언문 이전에 함수 호출이 가능하다. 이처럼 함수 선언문이 `코드의 선두로 끌어 올려진 것처럼 동작하는 것`이 호이스팅이다.

1. 전역 코드 평가 과정에서 함수 선언문이 먼저 실행되고 자바스크립트 엔진이 함수 이름과 동일한 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당한다. 즉, 식별자 key에 생성된 함수 객체가 바인딩 되어 환경 레코드에 등록된다.
2. 한 줄씩 실행되는 전역 코드 실행 과정(런타임)에 함수 호출문을 만나면 이미 해당 식별자에 함수 객체가 할당되어 있으므로 함수 선언문 이전에 함수를 호출할 수 있다.

## 함수 표현식

```jsx
const bar = function foo() {
  console.log('foo')
}

bar()
```

```jsx
const bar = function () {
  console.log('foo')
}

bar()
```

함수 리터럴로 생성한 함수 객체를 변수에 할당하는 방식이다. 변수 식별자로 함수를 호출하기 때문에 함수 이름을 생략할 수 있다.

### 호이스팅

함수 객체가 변수에 할당된 것이므로 변수 호이스팅에 주목해야한다.

소스 코드가 실행되는 동안 변수 할당문을 만나면 함수 객체가 할당되므로 변수 할당문보다 먼저 함수를 호출할 수 없다.

1. 소스 코드가 평가될 때 const나 let으로 선언된 변수 식별자가 환경 레코드에 key로 등록된다. 이때, 값이 할당되지 않고 자바스크립트 엔진이 암묵적으로 undefined으로 초기화하는 작업도 이루어지지 않는다.
2. 코드 실행 과정에서 변수 할당문을 만나면 변수에 함수 객체가 할당된다. 때문에 런타임 전에는 해당 식별자에 값이 바인딩 되어 있지 않으므로 `변수 할당문 이후에 함수를 호출할 수 있다.`

## 함수 인자 전달

```jsx
function Fn(string, number, obj) {
  string += '_string'
  number++

  Object.keys(obj).forEach((key) => (obj[key] = 'changed'))
}

const str = 'string'
const num = 5
const obj = { firstKey: 'value', secondKey: 6 }
```

### 원시 값

원시 값인 Number, String, Boolean, Null, Undefined는 함수 인자로 전달될 때 값이 복사되어 전달되므로 해당 매개변수는 새로운 주소 값을 갖는다. 원본 값과 해당 매개변수는 다른 주소 값을 갖기 때문에 함수 내부에서 값을 수정해도 원본 값은 변경되지 않는다.

### 참조 값

참조 값은 주소 값을 복사하여 전달하기 때문에 원본 객체와 동일한 주소 값을 갖는다. 때문에 함수 내부에서 객체를 변경할 경우 원본 값도 동일하게 변경된다

## 콜백 함수

함수 자체가 매개변수로 전달되어 `전달 받은 고차 함수에 의해 호출되는 함수`이다.

### 전달

매개변수에 동일한 콜백 함수를 여러번 전달할 때 리터럴이 아닌 변수에 담아 전달하자.

매개변수에 `함수를 리터럴로 전달하면 고차함수를 호출할 때마다 새로 함수 객체를 생성`하지만, `함수를 변수에 담아 전달하면 변수 할당문이 실행될 때 한 번만 함수가 생성`되기 때문에 더 효율적이다.

```jsx
const callback = function () {
  //...
}

fn(callback)
fn(function () {
  //...
})
```

## 일반 함수와 화살표 함수의 차이

1. 생성자 함수로 사용할 수 없다.
   1. constructor를 가지고 있지 않기 때문이다.
   2. 인스턴스를 생성하지 않기 때문에 인스턴스의 prototype을 할당하기 위해 필요한 prototype 프로퍼티를 갖지 않는다.
   3. 인스턴스를 생성하지 않기 때문에 생성할 인스턴스를 나타내는 this 또한 가지고 있지 않다.
2. this, arguments 등의 바인딩을 갖지 않는다.
   1. 화살표 함수에는 this가 바인딩되어있지 않기 때문에 화살표 함수 내의 this는 상위 스코프를 참조한다. this가 정적으로 결정되는 lexical this이다.
      1. 화살표 함수 내 this에 바인딩하는 객체를 변경할 수 없고, 메서드에 할당되거나 콜백함수 또는 내부 함수로 정의 되었을 때도 상위 스코프의 this를 참조한다.
3. 함수 선언문으로 작성된 일반 함수는 익명 함수로 작성할 수 없고, 함수 표현식으로 작성된 일반 함수는 익명 함수로 작성할 수 있다.
   화살표 함수는 익명 함수로만 작성할 수 있기 때문에 함수 표현식으로 함수를 작성해야 한다.

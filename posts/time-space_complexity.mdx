---
title: Big O
description: 빅오 표기법으로 알고리즘의 실행속도와 알고리즘이 실행되는 동안 차지하는 임시 메모리를 파악할 수 있다. 빅오는 정확도가 아니라 전체적인 추세에 초점을 맞춘다. 이를 통해 효과적인 알고리즘이 무엇인지 판단하고 비교할 수 있다.
createDate: '2022.10.3'
tag: 알고리즘
thumbnail: /thumbnail/time-space_complexity.png
---

# 시간 복잡도(Time Complexity)

> 알고리즘이 얼마나 빠르게 실행하는지 파악하는 척도이다.
> 연산이 얼마나 빠른가가 아니라 `얼마나 많은 계산 단계가 필요한지`를 파악한다.
> 데이터 원소가 N개일 때 알고리즘에 몇 단계가 필요한지 나타낸다.

## O(1)

n이 무한으로 커졌을 때의 전반적인 추이가 constant인 복잡도이다. 다시말해, one step으로 접근할 수 있는 상태이다.

### Example

- 산수  
  ⇒ 1 + 2
- 변수 배정  
  ⇒ let a
- 인덱스로 배열의 요소에 접근하는 것  
  ⇒ array[1]
- 오브젝트의 키로 값에 접근하는 것  
  ⇒ object.a

## O(n), O(n^2)…

- 루프가 존재하면, 루프의 길이 곱하기 루프 안 연산들이 존재하는 복잡도이다.

### Example

```jsx
/* O(n)
 * n <= 5, n이 커져도 5로 상수 복잡도 O(1)이 된다.
 * n > 5, n이 커질수록 복잡도와 1:1로 비례하므로 O(n)이 된다.
 * n > 5의 경우가 대부분이므로 전반적 추세로 보아 O(n)의 time complexity를 갖는다.
 */
function logAtLeast5(n) {
  for (let i = 1; i <= Math.max(5, n); i++) {
    console.log(i)
  }
}
```

```jsx
/* O(1)
 * n < 5, n이 커질 수록 복잡도도 n으로 비례하므로 O(n)이 된다.
 * n >= 5, n이 커져도 복잡도가 5로 일정하이므로 O(1)이 된다.
 * n >=5의 경우가 대부분이므로 전반적 추세로 보아 O(1)의 time complexity를 갖는다.
 */
function logAtMost5(n) {
  for (let i = 1; i <= Math.min(5, n); i++) {
    console.log(i)
  }
}
```

# 공간 복잡도 (Space Complexity)

> input의 메모리가 아닌 `알고리즘이 차지하는 보조 공간 복잡도`를 나타내는 것이다. 보조 공간이란 알고리즘이 실행되는 동안 사용하는 임시공간이다.

## O(1)

number, boolean, null, undefined는 불변 공간으로, input이 1이든 10000이든 같은 공간을 차지한다.

### Example

```jsx
// O(1)
function sum(array) {
  let total = 0
  for (let i = 0; i < array.length; i++) {
    total += array[i]
  }
  return total
}
```

## O(n)

- string는 문자 길이 만큼의 공간이 필요하다.
- reference type의 공간 복잡도로, Array는 길이만큼의 공간이 필요하고 Object는 key의 갯수만큼 공간이 필요하다.

### Example

```jsx
/* O(n)
 * newArray의 space complexity는 array의 길이와 동일하다.
 */
function double(array) {
  let newArray = []
  for (let i = 0; i < array.length; i++) {
    newArray.push(2 * array[i])
  }
  return newArray
}
```

## O(logN)

일반적으로 수학에서 밑이 10일 때 생략하지만 BigO에서는 밑이 2일 때 생략한다.

input이 1보다 작아지기 전에 2로 나눠지는 횟수를 뜻한다.
예를 들어, log8은 8이 1보다 작아지기 전 2로 나눠지는 횟수가 3번이므로 3이 된다고 말할 수 있다.

# Object의 BigO

### Access O(1)

특정 key의 value에 접근할 때는 한번에 접근할 수 있으므로 time complexity가 O(1)이다.

### insertion O(1)

새로운 key를 one step으로 접근하여 삽입할 수 있으므로 time complexity가 O(1)이다.

### removal O(1)

특정 key를 제거할 때 해당 key에 바로 접근하여 제거할 수 있으므로 time complexity가 O(1)이다.

### searching O(n)

특정 value를 가진 key가 존재하는지 검색하기 위해서는 모든 최대로 모든 key에 접근하여 확인을 해야하므로 time complexity가 O(n)이다.

### Object Methods

- Object.keys O(n)
- Object.values O(n)
- Object.entries O(n)
- hasOwnProperty O(1)

# Array의 BigO

object와 큰 차이점은 순서가 존재한다는 것이다.

### Access O(1)

index로 바로 접근이 가능하기 때문에 time complexity가 O(1)이다.

<aside>
배열을 선언하면 연속적인 Cell을 배열의 길이만큼 차지하게 되고, 각 Cell은 앞 Cell의 +1인 메모리 주소를 갖게 된다. 배열의 값에 index로 한 번에 접근 가능한 이유는, 첫번째 Cell의 주소와 타겟 요소의 index를 이용해 메모리주소 값을 얻어내어 접근할 수 있는 것이다.

</aside>

### insertion O(n)

정렬되어 있는 위치에 따라 다르다.
마지막에 추가하면 O(1)이지만, 맨 앞에 추가하면 그 뒤에 위치한 모든 요소가 메모리 주소 +1씩 밀려나기 때문에 O(n)이 된다.

### removal O(n)

정렬되어 있는 위치에 따라 다르다.
마지막 요소를 제거하면 O(1)이지만, 맨 앞 요소를 제거하면 그 뒤에 위치한 모든 요소의 메모리 주소가 1씩 당겨지기 때문에 O(n)이 된다.

### searching O(n)

특정 요소를 찾기 위해 한 Cell씩 확인하는 선형 검색으로 찾기 때문에 배열 길이 만큼 검색하는 단계는 증가한다.

### Array Methods

- push O(1)
- pop O(1)
- shift O(n)
- unshift O(n)
- concat O(n)  
  이어붙일 array의 길이만큼 걸리는 시간이 증가하기 때문이다.
- slice O(n)  
  복사하는 element 갯수만큼 걸리는 시간이 증가하기 때문이다.
- splice O(n)
- sort O(n x logN)  
  array 길이 n x 비교 횟수 logN이 된다.
- forEach O(n)
- map O(n)
- filter O(n)
- reduce O(n)
- …etc O(n)

# 배열에서의 집합

집합이란 중복 데이터가 없는 것을 의미한다.

읽기, 검색, 삭제는 일반 배열과 동일한 time complexity를 갖지만 삽입의 경우는 다르다.

삽입은 해당 요소가 존재한지 확인한 후 삽입해야 하므로 검색 N + 첫번째 요소에 삽입 N+1 (N개의 요소가 index +1씩 이동, 1 삽입)이 되어 2N + 1이 된다. 하지만 빅오는 전반적인 추이를 나타내므로 O(n)이 된다.

# 정렬된 배열

정렬된 배열의 경우 일반 배열보다 삽입이 느리다. 정렬이 유지되도록 검색 후 요소를 삽입해야하기 때문이다. 하지만 검색에서는 일반 배열보다 훨씬 빠르다.

일반 배열에서 검색 알고리즘은 선형검색으로 판단했지만, 정렬된 배열에서는 이진검색으로 검색에 필요한 최대 단계수를 대폭 줄일 수 있다.

<aside>
- 배열의 크기가 3일 때   
`선형 검색:` 3
`이진 검색:` 2

- 배열의 크기가 두배로 증가했을 때  
  `선형 검색:` 6
  `이진 검색:` 2 + 1
  …
- 배열의 크기가 100일 때  
  `선형 검색:` 100단계
  `이진 검색:` 7단계

</aside>

**데이터가 두배로 증가할 때마다 이진 검색의 단계수는 최대 1단계만 추가된다.**

데이터의 중점을 기준으로 좌/우 어느 쪽에 있는 지 판단 후 절반씩 제거하는 방향으로 검색이 되므로, O(logN)이 된다. 배열의 크기가 100일 때의 이진 검색이 7단계임을 계산해보면 log2(100) = 6.64…가 되어 7 단계임을 알 수 있다.

## 함수로 보는 BigO 표기법

```jsx
/** O(1)
 * input year이 무한이 되어도 최대 2번의 단계가 걸린다. 상수 단계이므로 시간 복잡도는 O(1)이다.
 */
function checkYear(year: number) {
  const isOdd = year % 2
  if (isOdd) {
    return '짝수입니다.'
  } else {
    return '홀수입니다.'
  }
}
```

```jsx
/** O(n)
 * 최대 input Array의 길이만큼 반목문을 돌면서 조건을 확인하므로 시간 복잡도는 O(n)이다.
 */
function order(fruits: string[]) {
  const cart = []

  for (let i = 0; i < fruits.length; i++) {
    const fruit = fruits[i]
    if (fruit.startsWith('a')) {
      cart.push(fruit)
    }
  }

  return cart
}
```

```jsx
/** O(logN)
 * 반복문의 횟수는 placedGrains이 grains을 넘는 시점이 되기까지 두배씩 몇번을 증가하는 지이다.
 * 다른말로, grains이 두배 증가하면 반복문이 실행되는 횟수는 +1이 된다.
 */
function chessboardSpace(grains: number) {
  let placedGrains = 1
  let chessboardSpaces = 1

  while (placedGrains < grains) {
    placedGrains *= 2
    chessboardSpaces += 1
  }

  return chessboardSpaces
}
```

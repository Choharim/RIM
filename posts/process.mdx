---
title: 프로세스
description: CPU는 한 번에 하나의 프로세스만 실행할 수 있기 때문에 여러 응용 프로그램이 실행되려면 운영체제가 적절히 CPU을 배분해주어야 한다. 시분할 시스템에서 운영체제가 프로그램을 관리 및 실행하는 과정을 살펴보자.
createDate: 2022.12.18
tag: 운영체제
---

## 프로세스 vs 프로그램

프로그램은 어떤 작업을 할 건지 절차가 저장장치에 저장되어 있는 정적 상태이다.

프로세스는 프로그램이 메모리에 올라와 실행된 동적 상태이다. 시스템의 작업 단위이고 테스크라도 한다.

<Picture src="process1.png" height={400} />

## 프로세스의 구조

> 코드 영역(텍스트 영역)

- 프로그램의 본문이 기술 된 곳이다.
- 프로세스가 실행되는 동안 변하지 않는 읽기 전용으로, 정적 할당 영역이다.

> 데이터 영역

- 본문에 사용되는 데이터가 저장되어 있다.
- 선언할 때 크기가 결정되므로 프로세스가 실행되는 동안 변하지 않는 읽기 전용, 정적 할당 영역이다.

> 힙 영역

- 동적으로 할당되는 변수 영역이다.
- 프로세스가 실행되는 동안 만들어지는 영역으로, 크기가 변경될 수 있는 동적 할당 영역이다. 읽기 쓰기가 가능하다.

> 스택 영역

- 프로세스를 작동하기 위해 커널이 유지하는 자료구조이다. 함수 호출 후 복귀시 돌아오는 메모리 주소와 지역 변수를 저장하는 곳이다.
- 스레드(CPU 작업 단위)가 작동하는 동안 추가되거나 삭제되는 동적 할당 영역이다.

## 프로세스 제어 블록 (PCB- process control block, TCB- task control block)

운영체제가 해당 프로세스를 실행하기 위해 필요한 데이터를 보관하는 자료 구조로, 모든 프로세스는 고유의 PCB를 갖는다.

### 구성

- 포인터  
  준비 상태와 대기 상태의 Queue의 포인터이다.
- 프로세스 상태  
  프로세스가 현재 어떤 상태에 있는지 나타낸다.
  문맥(context)를 이어가기 위함이다.
- 프로세스 구분자  
  프로세스 별로 구분하기 위한 고유 식별자이다.
- 프로그램 카운터  
  다음 실행될 명령어의 위치를 가리키는 카운터의 값을 저장한다.
- 프로세스 우선순위  
  높은 우선순위를 갖는 프로세스가 먼저 실행되고 더 자주 실행된다.
  커널 프로세스 > 사용자 프로세스이고, 커널과 사용자 프로세스끼리도 우선순위가 다르다.
- 각종 레지스터 정보  
  사용하던 레지스터의 중간값을 보관하여 다음 실행에 사용한다.
- 메모리 관리 정보  
  프로세스의 메모리 위치 정보와 메모리 보호를 위한 경계/한계 레지스터 값이 저장된다.
- 할당된 자원 정보  
  프로세스를 실행하기 위해 할당된 자원 정보 (입출력 자원, 오픈 파일 등..)가 저장된다.
- 계정 정보  
  CPU 할당 시간과 사용 시간, 계정 번호 등이 저장된다.
- 부모/자식 프로세스 구분자

## 프로세스의 상태

> 일괄 작업 시스템

프로세스가 생성되면 실행되고 완료된다. 하나의 프로세스가 완료된 후 새로운 프로세스가 실행될 수 있다.

> 시분할 시스템

각 프로세스가 여러 상태 변화를 통해 동시에 여러 프로세스가 실행되는 것처럼 작동한다.

운영체제가 어떻게 시간을 쪼개어 여러 프로세스에 CPU를 배분해주는지 살펴보자.

<Picture src="process2.png" height={600} />

### 생성 상태

1. 운영체제가 저장 장치에 있던 프로그램을 메모리의 적당한 위치로 가져온다.
2. 해당 프로세스를 처리하는 작업 지시서인 프로세스 제어 블록 (PCB- process control block)을 메모리의 운영체제 영역에 생성한다.

<aside>
💡 프로그램이 프로세스가 되려면 메모리에 올라오는 동시에 프로세스 제어 블록이 생성되어야 한다.

</aside>

### 준비 상태

생성된 프로세스가 우선순위 별로 Queue (우선순위 다단계 큐)에서 CPU를 얻을 때까지 기다리는 상태이다. CPU는 한 번에 하나의 프로세스만 실행할 수 있기 때문이다. (사실 프로세스가 아니라 스레드이다.)

### 실행 상태

CPU 스케쥴러가 해당 프로세스 제어 블록을 CPU에 전달하여 해당 프로세스가 실행되는 상태이다. 디스패치(dispatch)작업이라 한다.

배당된 작업 시간(time slice, time quantum)동안만 CPU를 사용할 권리를 갖으며, 자신의 작업이 끝날 때까지 준비와 실행 상태를 왔다 갔다 한다. 배당된 작업 시간이 지나 클록이 인터럽트를 사용하여 CPU에 알리면 준비 상태로 다시 이동한다. 작업을 끝내지 못하고 다시 준비 상태로 돌아가는 것을 time out이라 한다.

<aside>
❓ 문맥 교환 (Context Switching)  
CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업이다. 두 프로세스의 제어 블록이 교환된다.

</aside>

### 완료 상태

프로세스의 작업이 완료된 상태로, 메모리에서 삭제되고 프로세스 제어 블록이 폐기된다.

### 대기 상태

프로세스가 입출력을 요구하면 입출력 관리자에 의해 입출력이 완료될 때까지 같은 입출력 장치별로 마련된 Queue(입출력 다단계 큐)에서 기다리는 상태가 된다. 이때, CPU 스케쥴러는 준비 상태에 있는 프로세스 하나를 실행 상태로 만든다.
입출력이 완료되면 입출력 관리자로부터 인터럽트를 받고, 인터럽트가 온 입출력 장치의 Queue에서 해당 프로세스 블럭을 찾아 준비 상태로 이동시킨다.

### 휴식 상태

작업을 잠시 쉬고있는 휴식 상태로, 사용하던 데이터가 메모리에 그대로 있고 프로세스 제어 블록도 유지되므로 멈춘 지점에서 재시작할 수 있다.

프로세스가 자발적으로 선택한 상태이다. ms 시간 단위로 Sleep을 요청하는데, 요청한 시간이 지난 후 프로세스가 실행 되는 것이 아니다. 휴식 상태로 들어가기 위해 준비 Queue에서 선택되고(dequeue), 요청한 휴식 시간이 지난 후 다시 준비 Queue에 재진입(enqueue)하고, 자신의 차례가 될 때까지 기다리는 시간까지 합쳐져 요청한 시간에 + a 시간이 소요된다.

### 보류 상태

프로세스가 메모리 밖으로 잠시 쫒겨난 상태로 스왑 영역에 보관된다. 컴퓨터의 성능을 떨어트리거나 실행을 미루어도 큰 지장이 없는 프로세스가 보류 상태로 이동한다.

프로세스 자발적 상태 변환이 아니다.

- 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫒아도 큰 문제가 없을 때
- 입출력이 계속 지연될 때
- 메모리가 꽉 찼을 때
- 프로그램에 오류가 있을 때
- 악의적 프로세스일 때

**보류 대기 상태**

대기 상태에서 옮겨진 보류 상태로, 재시작 하면 대기 상태로 이동한다. 입출력을 요청했던 프로세스가 보류 대기 상태에 있다가 입출력 완료 인터럽트를 받게되면 해당 프로세스 제어 블록은 보류 준비 상태로 이동한다.

**보류 준비 상태**

준비 상태에서 옮겨진 보류 상태로, 재시작하면 준비 상태로 이동한다.

---
title: 물리 메모리 관리
description: 메모리 분할 방식과 같은 물리적 메모리 관리의 기본 사항을 살펴보자. 메모리를 할당하고 할당을 해제하는 과정에서 발생하는 조각화와 이를 해결하는 방법을 알아보자.
createDate: 2022.12.30
category: operating-system
---

## 메모리 관리

폰노이만 구조에서 프로그램이 실행되기 위해서는 메모리에 올라와야 한다. 오늘날의 시분할 시스템은 운영체제를 포함한 여러 응용 프로그램이 실행되기 때문에 메모리를 어떻게 관리하는지가 중요하다. 이처럼 복잡한 메모리 관리는 `메모리 관리 시스템`(Memory Management System)이 담당한다.

### 이중성

프로세스 입장에서는 편하게 작업하기 위해 메모리를 독차지하려 하고, 메모리 관리자 입장에서는 효율적으로 관리하려 한다. 이처럼 상충되는 요구 사항을 메모리 관리 시스템이 처리한다.

### 메모리 관리자의 역할

하드웨어 메모리 관리자는 `메모리 관리 유닛`이라는 하드웨어이다. 메모리 관리자는 프로세스와 데이터를 메모리로 가져와 어느 곳에 위치할지 결정하고, 새로운 프로세스를 가져오기 위해 특정 프로세스를 내보내 공간을 확보하는 작업을 한다.

> 가져오기 작업 (Fetch), 미리 가져오기 작업 (Prefetch)

사용자가 요청한 프로세스와 데이터를 메모리로 가져온다. 앞으로 사용할 거라 예상되는 데이터를 미리 가져오기도 한다.

> 배치 작업 (Placement)

같은 크기로 메모리 영역을 나누는 페이징(Paging) 또는 프로세스 또는 작업 크기에 맞게 나누는 세그먼테이션(Segmentation)방법으로 메모리를 나누고, 프로세스를 어떻게 배치할지 결정한다.

한정된 메모리를 효율적으로 사용하기 위한 작업으로, 시스템의 효율을 좌우하는 중요한 기준이다.

> 재배치 작업 (Replacement)

새로운 프로세스를 가져오기 위해 특정 프로세스를 메모리에서 내보내 저장장치로 옮기고 부족한 메모리 공간을 확보하는 작업이다.

## 메모리 주소

### 메모리 영역의 구분

메모리의 영역은 크게 `운영체제 영역`과 `사용자 영역`으로 이루어져 있다. 사용자 영역이 운영체제 영역을 `침범하려 하면 인터럽트가 발생`하고 해당 사용자 프로세스는 강제 종료된다. CPU의 `경계 레지스터가 운영체제 영역과 사용자 영역 경계 지점의 주소를 가지고 있어` 메모리 관리자가 경계 레지스터 값을 확인하여 범위를 검사하는 것이다.

### 절대 주소와 상대 주소

**절대 주소**는 메모리 주소 레지스터가 사용하는 `실제 물리 주소 공간`으로, 램 메모리의 실제 주소를 말한다.

**상대 주소**는 `사용자 영역이 시작되는 번지를 0번지로 기준을 잡고 주소를 지정하는 방식`이다. 논리 주소 공간이라고 부른다. 상대 주소를 사용하므로써 사용자 프로세스가 `매번 운영체제 영역을 확인하지 않아도 되고 실제 메모리 주소를 알 필요도 없기 때문에 편리`하다.

<aside>
❓ **상대 주소 —> 절대 주소 변환**

1. 사용자 프로세스가 상대 주소(a)로 데이터를 요청한다.
2. CPU가 메모리 관리자에게 상대 주소(a)의 데이터를 가져오라고 명령한다.
3. 메모리 관리자가 `상대 주소 + 메모리 세그먼트의 기본 주소` 로 절대 주소를 구한다.

</aside>

<aside>
➕ **32bit CPU는 무엇을 뜻할까**

32bit CPU는 `한 번에 이동시킬 수 있고 연산할 수 있는 최대 데이터의 크기가 32bit`라는 소리이다. 때문에 내부 장치(산술 논리 연산 장치, 레지스터, 내부 버스 대역폭)도 32bit를 갖고, 운영체제 또한 32bit용을 사용해야 한다.

주소와 메모리 관점에서 보자.

bit는 데이터의 기본 단위로 1bit는 0 또는 1이 들어갈 수 있는 데이터 크기이다. 32bit는 0과 1을 저장할 수 있는 자리가 32개 있으므로 `2^32개의 데이터를 표현할 수 있다.`

메모리의 주소도 총 2^32개이니 `0부터 2^32 -1의 주소 범위`를 갖게 된다.

주소의 기본 단위는 1byte이므로(메모리는 1byte로 나누어져 있고 이를 주소로 구분한다.) `1byte * 2^32 = 2^32B, 약 4GB의 메모리 크기`를 갖는다.

</aside>

## 단일 프로그래밍 환경에서의 메모리 할당

### 오버레이

프로그램의 크기가 (물리)메모리보다 클 때 `프로그램을 모듈로 나누어 필요한 모듈만 메모리에 가져오는 방법`이다. 다음에 실행할 모듈이 메모리에 없으면 프로그램 카운터가 메모리 관리자에게 요청한다.

### 스왑 영역

`메모리에서 쫒겨난 프로세스가 보관되는 저장 장치의 영역`이다. 작업이 완료되지 않았고 다시 사용될 수도 있기 때문이다. 저장 장치는 저장 장치 관리자가 관리하지만, 저장 장치의 스왑 영역에 있는 데이터는 다시 메모리로 돌아가기 때문에 `메모리 관리자가 관리`한다.
저장 장치의 `스왑 영역에서 메모리로 데이터를 가져오는 작업을 스왑 인`이라 하고, `메모리에서 스왑 영역으로 내보내는 작업을 스왑 아웃`이라 한다.

## 다중 프로그래밍 환경에서의 메모리 할당

### 메모리 분할 방식

> 가변 분할 방식 (Segmentation)

`프로세스의 크기에 맞게` 메모리를 나누는 방식이다.

- 한 프로세스가 연속된 공간에 배치되기 때문에 `연속 메모리 할당`이라고 한다.
- 프로세스가 작업을 마치고 메모리에서 나가게 되면 빈 영역이 생기게 된다. `한 프로세스를 분산시켜 배치할 수 없기 때문에` 새로운 프로세스가 하나의 빈 영역보다 크면 배치될 수 없다. 이로인해 `메모리 통합 등의 부가적인 작업이 필요`하기 때문에 메모리 관리가 복잡하다.

<aside>
❓ **단편화, 조각화 (Fragment)**  
`한 프로세스가 차지한 분할된 메모리 영역에서 남은 영역`을 단편화, 조각화라고 한다. `다른 프로세스가 사용할 수 없으므로 메모리가 낭비`되는 부분이다.
단편화 문제는 메모리 뿐만 아니라 저장 장치에서도 발생한다.

</aside>

<aside>
❓ **외부 단편화**  
가변 분할 방식에서 발생하는 남은 빈 영역(단편화)은 `프로세스 바깥쪽에서 발생`하기 때문에 외부 단편화라고 한다.

</aside>

> 고정 분할 방식 (Paging)

프로세스의 크기와 상관없이 `메모리를 같은 크기로` 나누는 방식이다.

- 프로세스 크기가 하나의 분할된 메모리 영역보다 크면 다른 분할 영역을 추가로 사용한다. 분산되어 배치되기 때문에 `비연속 메모리 할당`이라고 한다.
- 한 프로세스를 분산시켜 배치할 수 있기 때문에 메모리 통합 등의 작업이 필요하지 않아 메모리 관리가 수월하다. 때문에 메모리 관리 시스템에서 기본으로 사용되는 방식이다.
- 나누어진 공간보다 작은 프로세스가 사용할 경우 메모리 낭비가 발생한다.

<aside>
❓ **내부 단편화**  
나뉜 메모리의 크기보다 작은 크기의 프로세스가 배치될 경우 단편화가 발생한다. `같은 크기로 나뉜 공간의 내부`에서 발생하기 때문에 내부 단편화라 한다.

</aside>

### 외부 단편화 해결 방법

> 메모리 배치 방식

- **최초 배치 (외부 단편화 고려 X)**  
  빈 메모리 공간을 순차적으로 찾다가 첫 번째로 발견한 공간에 프로세스를 배치하는 방법이다.
- **최적 배치**  
  메모리의 빈 공간을 모두 확인한 후 적재할 프로세스가 사용할 수 있는 크기 중 가장 작은 공간에 배치하는 방법이다.
- **최악 배치**  
  메모리의 빈 공간을 모두 확인한 후 가장 큰 공간에 프로세스를 배치하는 방법이다.
- **버디 시스템**  
  메모리를 절반으로 나누어 가며 프로세스의 크기에 맞는 영역을 배치한다. 더 큰 영역이 필요할 때는 동일한 크기로 나누어진 공간을 합쳐 영역을 확보한다. 크기가 동일한 영역이 합쳐지는 것이기 때문에 통합이 쉽다. 더 작은 블록을 재사용하여 메모리를 효율적으로 사용할 수 있다.
  조각화를 줄이는 데 효과적이다. Linux 및 Windows를 포함한 최신 운영 체제에서 널리 사용된다.

> 조각 모음

메모리 배치 방식을 사용해도 단편화가 발생한다. 조각모음은 이미 배치된 프로세스들을 옆으로 옮겨 `단편화를 모아 큰 공간으로 만드는 것`이다.

조각 모음을 하기 위한 과정은 다음과 같다.

1. 조각 모음을 하기 전 이동시킬 프로세스의 동작을 멈춘다.
2. 프로세스를 이동한다. 이때 상대 주소값도 바꾼다.
3. 작업을 마친 후 프로세스를 재시작한다.

### 내부 단편화 해결 방법

동일하게 분할되는 공간의 크기를 조절하여 내부 단편화를 최소화한다.

---
title: 컴퓨터 성능 향상 기술
description: 장치간의 속도 차이를 개선하는 방법과 시스템 속도를 향상시키는 방법을 알아보자.
createDate: 2022.12.15
tag: 운영체제
---

<aside>
📌 메모리와 주변 장치는 시스템 버스로 연결되어 있다. CPU의 산술 논리 연산 장치와 제어 장치, 레지스터는 CPU 내부 버스로 연결되어 있다. CPU 내부 버스가 시스템 버스보다 속도가 빠르기 때문에 CPU와 메모리, 주변장치간 속도 차이가 난다. **장치간의 속도 차이를 개선하는 방법**과 **시스템 속도를 향상시키는 방법**을 알아보자.

</aside>

## 버퍼

일정량의 데이터를 모아 옮김으로써 속도의 차이를 완화하는 장치이다.
버퍼가 다 찬 후 버퍼에 있는 데이터를 저장 장치에 옮기기 때문에 버퍼가 차기전 연결을 끊으면 저장되지 않은 데이터가 있을 수 있다.
여러 프로그램들이 버퍼를 공유한다.

### 사용 예시

대부분의 입출력 장치는 버퍼를 이용하여 느린 속도를 보완한다.

커널에서도 버퍼를 사용한다. 커널이 입출력 장치로 보낼 데이터를 버퍼에 담으면 입출력 제어기가 커널 버퍼에서 입출력 장치로 데이터를 이동시킨다. 커널이 버퍼를 이용하여 입출력 작업이 완료되기 전에 다른 작업을 할 수 있다.

## 스풀

CPU와 입출력 장치가 독립적으로 작동하도록 고안된 소프트웨어적 버퍼이다.
하나의 프로그램만 사용할 수 있기 때문에 프로그램 간에 배타적이다.

응용 프로그램이 스풀러를 사용하여 입출력 작업이 완료되기 전에 다른 작업을 할 수 있다.

## 캐시

CPU가 앞으로 사용할 것으로 예상되는 일정량의 데이터를 메모리에서 미리 가져와 저장해두는 임시 장소이다.

CPU안에 있어 시스템 버스를 이용하는 메모리보다 속도가 빠르기 때문에 CPU와 메모리의 속도 차이를 줄여주는 역할을 한다.

### 캐시 적중률

CPU는 필요한 데이터가 있으면 캐시를 먼저 방문해 찾아본다. 필요한 데이터를 캐시에서 찾았다면 캐시 히트(cache hit), 없다면 캐시 미스(cache miss)라고 한다. 캐시 히트의 비율을 캐시 적중률이라고 한다.

캐시 적중률을 높이는 방법은 다음과 같다

- 캐시 크기 늘린다.
  미리 가져오는 데이터가 많을 수록 캐시 히트의 비율이 많아진다.
- ‘지역성 이론’에 따라 시간적으로나 공간적으로 가까운 데이터를 사용할 확률이 높기 때문에 가까운 데이터를 미리 가져온다.
  - 시간의 지역성: 현재를 기준으로 가장 가까운 시간에 접근한 데이터가 더 먼 시간에 접근한 데이터보다 사용될 확률이 높다.
  - 공간의 지역성: 현재 위치에서 가까운 데이터에 접근할 확률이 더 먼거리에 있는 데이터에 접근할 확률보다 높다.

<aside>
❓ 캐싱된 데이터가 변경된다면, 메모리에 있는 원래 데이터와 어떻게 일치시킬까?

- 즉시 쓰기
  캐싱 데이터가 변경되면 즉시 메모리에 반영시키는 것이다.
  메모리와의 빈번한 데이터 전송으로 인해 성능이 느려지긴 하지만, 항상 최신값을 유지할 수 있다.
- 지연 쓰기
  변경된 데이터를 모아 주기적으로 한꺼번에 반영하는 것이다. 카피 백(copy back)이라고 한다.

</aside>

### 캐시 종류

메모리에 저장되는 것은 어떤 작업을 할지 나타내는 **명령어**와 작업 대상인 **데이터**로 나눌 수 있다. 이를 구분하지 않고 가져오는 일반 캐시와 구분해서 가져오는 특수 캐시가 있다.

**L1 (level 1) 캐시 - 특수 캐시**

CPU의 레지스터와 직접 연결되기 때문에 level 1이라 한다.

- 명령어 캐시
  CPU의 명령어 레지스터와 연결되어 있다.
- 데이터 캐시
  CPU의 데이터 레지스터와 연결되어 있다.

**L2 (level 2) 캐시 - 일반 캐시**

메모리와 연결되기 때문에 level 2이라 한다.

## 저장 장치 계층 구조

속도가 빠르고 비싼 저장 장치를 CPU쪽, 값 싸고 덜 빠르고 용량이 큰 저장 장치를 반대쪽에 배치하여 적당한 가격으로 빠른 속도와 큰 용량을 얻는다.

## 인터럽트

CPU가 작업을 중단하고 처리해야 하는 신호라는 의미로 인터럽트라 한다. 신호를 보낼 땐 고유 번호인 `인터럽트 번호`를 보내고, 해당 인터럽트가 발생했을 때 실행될 함수인 `인터럽트 핸들러` 와 연결되어 있다.

하드웨어 인터럽트의 경우, 어느 하드웨어에서 발생한 인터럽트인지 파악하기 위해 고유의 `IRQ`(Interrupt ReQuest)번호가 부여된다. 인터럽트 번호와 IRQ 번호는 일대일로 대응된다.

### 분류

- 트랩: 사용자 의지와 상관없이 발생하는 인터럽트
  - 데이터 입출력이 완료되었을 때 입출력 관리자로부터의 인터럽트
  - 실행 중인 작업이 주어진 메모리 영역을 넘으려 할 때 경계, 한계 레지스터로부터의 인터럽트
  - 숫자를 0으로 나눌 때
  - 하드웨어적 오류 발생으로 인한 하드웨어 인터럽트
- 시그널: 사용자가 발생시키는 인터럽트
  - 작동 중인 프로세스를 종료하려고 Ctrl + C로 강제 종료

### 인터럽트 벡터

입출력이 동시에 끝나는 경우 처럼 여러 개의 인터럽트를 한 번에 처리하기 위한 자료구조이다.

인터럽트 핸들러는 인터럽트 발생시 처리하는 방법을 함수로 만들어놓은 것이다. 인터럽트와 인터럽트 핸들러를 일대일로 연결하고 있다. 인터럽트가 발생하면 인터럽트 벡터의 번호가 0에서 1로 바뀌고, 인터럽트 벡터에 저장된 인터럽트 핸들러의 메모리 주소로 인터럽트 핸들러가 실행된다.

### 이중 모드

사용자 프로세스가 커널 기능을 사용하기 위해 시스템 호출을 요청하면 대기 상태로 전환되고 커널 프로세스는 요청받은 작업을 처리한다. 즉, 사용자 모드(User Mode)에서 커널 모드(kernel Mode)로 전환된다. 이처럼 두 모드를 전환하는 것을 이중 모드라 한다.

운영체제가 자원을 보호하기 위해 사용자 프로세스가 시스템 호출을 통해서만 자원에 접근하도록 제한하여 생긴 기법이다.

## 입출력 관리자로부터의 인터럽트

CPU와 데이터의 입출력을 독립적으로 운영하여 CPU가 다른 작업을 할 수 있게 해 시스템의 효율을 높인다.

동작 과정은 다음과 같다.

1. CPU가 입출력 관리자에게 명령을 보낸다.
2. 입출력 관리자는 명령받은 데이터를 메모리에 가져다 놓거나, 메모리에 있는 데이터를 저장장치로 옮긴다.
3. 데이터 전송이 완료되면 입출력 관리자는 완료 신호 (인터럽트)를 CPU에 보낸다.
4. CPU는 작업 중인 일을 중단하고 옮겨진 데이터를 처리한다.

<aside>
❓ 폴링 (Polling)
CPU가 직접 입출력장치에서 데이터를 가져오거나 내보내는 방식이다.

</aside>

### 직접 메모리 접근 권한

CPU만 메모리에 접근할 수 있기 때문에 입출력 관리자가 CPU가 요청한 데이터를 메모리에 가져다 놓을 때 접근 권한을 가져야 한다. 입출력 관리자는 입출력 제어기로, 직접 메모리에 접근하기 위한 DMA(direct memory access)제어기가 마련되어 있다.

‘DMA가 사용하는 데이터’와 ‘CPU가 사용하는 데이터’가 메모리에 섞이는 것을 방지하기 위해 공간을 분리한다. 이처럼 메모리의 일정 공간을 입출력에 할당하는 기법을 `메모리 맵 입출력`이라고 한다.

<aside>
❓ CPU와 입출력 관리자가 동시에 메모리에 접근할 때는 어떻게 될까?
CPU의 속도가 더 빠르기 때문에 CPU가 메모리 사용 권한을 양보한다. CPU 입장에서는 직접 메모리 접근이 순서를 훔쳐간 것이기 때문에 `사이클 훔치기` 라고 부른다.

</aside>
